{"remainingRequest":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\node_modules\\babel-loader\\lib\\index.js!D:\\MyProjects\\HbuilderX-projects\\2.19z\\src\\js\\Parser.js","dependencies":[{"path":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\src\\js\\Parser.js","mtime":1584139706000},{"path":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1582103017138},{"path":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\node_modules\\babel-loader\\lib\\index.js","mtime":1582103090028}],"contextDependencies":[],"result":["import _classCallCheck from \"D:\\\\MyProjects\\\\HbuilderX-projects\\\\2.19z\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\MyProjects\\\\HbuilderX-projects\\\\2.19z\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\nvar Renderer = require(\"./Renderer.js\");\n\nvar Slugger = require(\"./Slugger.js\");\n\nvar InlineLexer = require(\"./InlineLexer.js\");\n\nvar TextRenderer = require(\"./TextRenderer.js\");\n\nvar _require = require(\"./defaults.js\"),\n    defaults = _require.defaults;\n\nvar _require2 = require(\"./helpers.js\"),\n    merge = _require2.merge,\n    unescape = _require2.unescape;\n/**\n * Parsing & Compiling\n */\n\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function Parser(options) {\n    _classCallCheck(this, Parser);\n\n    this.tokens = [];\n    this.token = null;\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.slugger = new Slugger();\n  }\n  /**\n   * Static Parse Method\n   */\n\n\n  _createClass(Parser, [{\n    key: \"parse\",\n\n    /**\n     * Parse Loop\n     */\n    value: function parse(tokens) {\n      this.inline = new InlineLexer(tokens.links, this.options); // use an InlineLexer with a TextRenderer to extract pure text\n\n      this.inlineText = new InlineLexer(tokens.links, merge({}, this.options, {\n        renderer: new TextRenderer()\n      }));\n      this.tokens = tokens.reverse();\n      var out = '';\n\n      while (this.next()) {\n        out += this.tok();\n      }\n\n      return out;\n    }\n  }, {\n    key: \"next\",\n\n    /**\n     * Next Token\n     */\n    value: function next() {\n      this.token = this.tokens.pop();\n      return this.token;\n    }\n  }, {\n    key: \"peek\",\n\n    /**\n     * Preview Next Token\n     */\n    value: function peek() {\n      return this.tokens[this.tokens.length - 1] || 0;\n    }\n  }, {\n    key: \"parseText\",\n\n    /**\n     * Parse Text Tokens\n     */\n    value: function parseText() {\n      var body = this.token.text;\n\n      while (this.peek().type === 'text') {\n        body += '\\n' + this.next().text;\n      }\n\n      return this.inline.output(body);\n    }\n  }, {\n    key: \"tok\",\n\n    /**\n     * Parse Current Token\n     */\n    value: function tok() {\n      var body = '';\n\n      switch (this.token.type) {\n        case 'space':\n          {\n            return '';\n          }\n\n        case 'hr':\n          {\n            return this.renderer.hr();\n          }\n\n        case 'heading':\n          {\n            return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape(this.inlineText.output(this.token.text)), this.slugger);\n          }\n\n        case 'code':\n          {\n            return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);\n          }\n\n        case 'table':\n          {\n            var header = '',\n                i,\n                row,\n                cell,\n                j; // header\n\n            cell = '';\n\n            for (i = 0; i < this.token.header.length; i++) {\n              cell += this.renderer.tablecell(this.inline.output(this.token.header[i]), {\n                header: true,\n                align: this.token.align[i]\n              });\n            }\n\n            header += this.renderer.tablerow(cell);\n\n            for (i = 0; i < this.token.cells.length; i++) {\n              row = this.token.cells[i];\n              cell = '';\n\n              for (j = 0; j < row.length; j++) {\n                cell += this.renderer.tablecell(this.inline.output(row[j]), {\n                  header: false,\n                  align: this.token.align[j]\n                });\n              }\n\n              body += this.renderer.tablerow(cell);\n            }\n\n            return this.renderer.table(header, body);\n          }\n\n        case 'blockquote_start':\n          {\n            body = '';\n\n            while (this.next().type !== 'blockquote_end') {\n              body += this.tok();\n            }\n\n            return this.renderer.blockquote(body);\n          }\n\n        case 'list_start':\n          {\n            body = '';\n            var ordered = this.token.ordered,\n                start = this.token.start;\n\n            while (this.next().type !== 'list_end') {\n              body += this.tok();\n            }\n\n            return this.renderer.list(body, ordered, start);\n          }\n\n        case 'list_item_start':\n          {\n            body = '';\n            var loose = this.token.loose;\n            var checked = this.token.checked;\n            var task = this.token.task;\n\n            if (this.token.task) {\n              if (loose) {\n                if (this.peek().type === 'text') {\n                  var nextToken = this.peek();\n                  nextToken.text = this.renderer.checkbox(checked) + ' ' + nextToken.text;\n                } else {\n                  this.tokens.push({\n                    type: 'text',\n                    text: this.renderer.checkbox(checked)\n                  });\n                }\n              } else {\n                body += this.renderer.checkbox(checked);\n              }\n            }\n\n            while (this.next().type !== 'list_item_end') {\n              body += !loose && this.token.type === 'text' ? this.parseText() : this.tok();\n            }\n\n            return this.renderer.listitem(body, task, checked);\n          }\n\n        case 'html':\n          {\n            // TODO parse inline content if parameter markdown=1\n            return this.renderer.html(this.token.text);\n          }\n\n        case 'paragraph':\n          {\n            return this.renderer.paragraph(this.inline.output(this.token.text));\n          }\n\n        case 'text':\n          {\n            return this.renderer.paragraph(this.parseText());\n          }\n\n        default:\n          {\n            var errMsg = 'Token with \"' + this.token.type + '\" type was not found.';\n\n            if (this.options.silent) {\n              console.log(errMsg);\n            } else {\n              throw new Error(errMsg);\n            }\n          }\n      }\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n  }]);\n\n  return Parser;\n}();",{"version":3,"sources":["D:\\MyProjects\\HbuilderX-projects\\2.19z\\src\\js\\Parser.js"],"names":["Renderer","require","Slugger","InlineLexer","TextRenderer","defaults","merge","unescape","module","exports","options","tokens","token","renderer","slugger","inline","links","inlineText","reverse","out","next","tok","pop","length","body","text","peek","type","output","hr","heading","depth","code","lang","escaped","header","i","row","cell","j","tablecell","align","tablerow","cells","table","blockquote","ordered","start","list","loose","checked","task","nextToken","checkbox","push","parseText","listitem","html","paragraph","errMsg","silent","console","log","Error","parser","Parser","parse"],"mappings":"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","sourcesContent":["const Renderer = require('./Renderer.js');\nconst Slugger = require('./Slugger.js');\nconst InlineLexer = require('./InlineLexer.js');\nconst TextRenderer = require('./TextRenderer.js');\nconst { defaults } = require('./defaults.js');\nconst {\n  merge,\n  unescape\n} = require('./helpers.js');\n\n/**\n * Parsing & Compiling\n */\nmodule.exports = class Parser {\n  constructor(options) {\n    this.tokens = [];\n    this.token = null;\n    this.options = options || defaults;\n    this.options.renderer = this.options.renderer || new Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.slugger = new Slugger();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens, options) {\n    const parser = new Parser(options);\n    return parser.parse(tokens);\n  };\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens) {\n    this.inline = new InlineLexer(tokens.links, this.options);\n    // use an InlineLexer with a TextRenderer to extract pure text\n    this.inlineText = new InlineLexer(\n      tokens.links,\n      merge({}, this.options, { renderer: new TextRenderer() })\n    );\n    this.tokens = tokens.reverse();\n\n    let out = '';\n    while (this.next()) {\n      out += this.tok();\n    }\n\n    return out;\n  };\n\n  /**\n   * Next Token\n   */\n  next() {\n    this.token = this.tokens.pop();\n    return this.token;\n  };\n\n  /**\n   * Preview Next Token\n   */\n  peek() {\n    return this.tokens[this.tokens.length - 1] || 0;\n  };\n\n  /**\n   * Parse Text Tokens\n   */\n  parseText() {\n    let body = this.token.text;\n\n    while (this.peek().type === 'text') {\n      body += '\\n' + this.next().text;\n    }\n\n    return this.inline.output(body);\n  };\n\n  /**\n   * Parse Current Token\n   */\n  tok() {\n    let body = '';\n    switch (this.token.type) {\n      case 'space': {\n        return '';\n      }\n      case 'hr': {\n        return this.renderer.hr();\n      }\n      case 'heading': {\n        return this.renderer.heading(\n          this.inline.output(this.token.text),\n          this.token.depth,\n          unescape(this.inlineText.output(this.token.text)),\n          this.slugger);\n      }\n      case 'code': {\n        return this.renderer.code(this.token.text,\n          this.token.lang,\n          this.token.escaped);\n      }\n      case 'table': {\n        let header = '',\n          i,\n          row,\n          cell,\n          j;\n\n        // header\n        cell = '';\n        for (i = 0; i < this.token.header.length; i++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(this.token.header[i]),\n            { header: true, align: this.token.align[i] }\n          );\n        }\n        header += this.renderer.tablerow(cell);\n\n        for (i = 0; i < this.token.cells.length; i++) {\n          row = this.token.cells[i];\n\n          cell = '';\n          for (j = 0; j < row.length; j++) {\n            cell += this.renderer.tablecell(\n              this.inline.output(row[j]),\n              { header: false, align: this.token.align[j] }\n            );\n          }\n\n          body += this.renderer.tablerow(cell);\n        }\n        return this.renderer.table(header, body);\n      }\n      case 'blockquote_start': {\n        body = '';\n\n        while (this.next().type !== 'blockquote_end') {\n          body += this.tok();\n        }\n\n        return this.renderer.blockquote(body);\n      }\n      case 'list_start': {\n        body = '';\n        const ordered = this.token.ordered,\n          start = this.token.start;\n\n        while (this.next().type !== 'list_end') {\n          body += this.tok();\n        }\n\n        return this.renderer.list(body, ordered, start);\n      }\n      case 'list_item_start': {\n        body = '';\n        const loose = this.token.loose;\n        const checked = this.token.checked;\n        const task = this.token.task;\n\n        if (this.token.task) {\n          if (loose) {\n            if (this.peek().type === 'text') {\n              const nextToken = this.peek();\n              nextToken.text = this.renderer.checkbox(checked) + ' ' + nextToken.text;\n            } else {\n              this.tokens.push({\n                type: 'text',\n                text: this.renderer.checkbox(checked)\n              });\n            }\n          } else {\n            body += this.renderer.checkbox(checked);\n          }\n        }\n\n        while (this.next().type !== 'list_item_end') {\n          body += !loose && this.token.type === 'text'\n            ? this.parseText()\n            : this.tok();\n        }\n        return this.renderer.listitem(body, task, checked);\n      }\n      case 'html': {\n        // TODO parse inline content if parameter markdown=1\n        return this.renderer.html(this.token.text);\n      }\n      case 'paragraph': {\n        return this.renderer.paragraph(this.inline.output(this.token.text));\n      }\n      case 'text': {\n        return this.renderer.paragraph(this.parseText());\n      }\n      default: {\n        const errMsg = 'Token with \"' + this.token.type + '\" type was not found.';\n        if (this.options.silent) {\n          console.log(errMsg);\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n  };\n};\n"]}]}