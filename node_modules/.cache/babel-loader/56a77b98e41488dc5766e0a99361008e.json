{"remainingRequest":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\node_modules\\babel-loader\\lib\\index.js!D:\\MyProjects\\HbuilderX-projects\\2.19z\\src\\js\\Lexer.js","dependencies":[{"path":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\src\\js\\Lexer.js","mtime":1584139706000},{"path":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1582103017138},{"path":"D:\\MyProjects\\HbuilderX-projects\\2.19z\\node_modules\\babel-loader\\lib\\index.js","mtime":1582103090028}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport _classCallCheck from \"D:\\\\MyProjects\\\\HbuilderX-projects\\\\2.19z\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"D:\\\\MyProjects\\\\HbuilderX-projects\\\\2.19z\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/createClass\";\n\nvar _require = require(\"./defaults.js\"),\n    defaults = _require.defaults;\n\nvar _require2 = require(\"./rules.js\"),\n    block = _require2.block;\n\nvar _require3 = require(\"./helpers.js\"),\n    rtrim = _require3.rtrim,\n    splitCells = _require3.splitCells,\n    escape = _require3.escape;\n/**\n * Block Lexer\n */\n\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function Lexer(options) {\n    _classCallCheck(this, Lexer);\n\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.rules = block.normal;\n\n    if (this.options.pedantic) {\n      this.rules = block.pedantic;\n    } else if (this.options.gfm) {\n      this.rules = block.gfm;\n    }\n  }\n  /**\n   * Expose Block Rules\n   */\n\n\n  _createClass(Lexer, [{\n    key: \"lex\",\n\n    /**\n     * Preprocessing\n     */\n    value: function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      return this.token(src, true);\n    }\n  }, {\n    key: \"token\",\n\n    /**\n     * Lexing\n     */\n    value: function token(src, top) {\n      src = src.replace(/^ +$/gm, '');\n      var next, loose, cap, bull, b, item, listStart, listItems, t, space, i, tag, l, isordered, istask, ischecked;\n\n      while (src) {\n        // newline\n        if (cap = this.rules.newline.exec(src)) {\n          src = src.substring(cap[0].length);\n\n          if (cap[0].length > 1) {\n            this.tokens.push({\n              type: 'space'\n            });\n          }\n        } // code\n\n\n        if (cap = this.rules.code.exec(src)) {\n          var lastToken = this.tokens[this.tokens.length - 1];\n          src = src.substring(cap[0].length); // An indented code block cannot interrupt a paragraph.\n\n          if (lastToken && lastToken.type === 'paragraph') {\n            lastToken.text += '\\n' + cap[0].trimRight();\n          } else {\n            cap = cap[0].replace(/^ {4}/gm, '');\n            this.tokens.push({\n              type: 'code',\n              codeBlockStyle: 'indented',\n              text: !this.options.pedantic ? rtrim(cap, '\\n') : cap\n            });\n          }\n\n          continue;\n        } // fences\n\n\n        if (cap = this.rules.fences.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'code',\n            lang: cap[2] ? cap[2].trim() : cap[2],\n            text: cap[3] || ''\n          });\n          continue;\n        } // heading\n\n\n        if (cap = this.rules.heading.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'heading',\n            depth: cap[1].length,\n            text: cap[2]\n          });\n          continue;\n        } // table no leading pipe (gfm)\n\n\n        if (cap = this.rules.nptable.exec(src)) {\n          item = {\n            type: 'table',\n            header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n            align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n            cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n          };\n\n          if (item.header.length === item.align.length) {\n            src = src.substring(cap[0].length);\n\n            for (i = 0; i < item.align.length; i++) {\n              if (/^ *-+: *$/.test(item.align[i])) {\n                item.align[i] = 'right';\n              } else if (/^ *:-+: *$/.test(item.align[i])) {\n                item.align[i] = 'center';\n              } else if (/^ *:-+ *$/.test(item.align[i])) {\n                item.align[i] = 'left';\n              } else {\n                item.align[i] = null;\n              }\n            }\n\n            for (i = 0; i < item.cells.length; i++) {\n              item.cells[i] = splitCells(item.cells[i], item.header.length);\n            }\n\n            this.tokens.push(item);\n            continue;\n          }\n        } // hr\n\n\n        if (cap = this.rules.hr.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'hr'\n          });\n          continue;\n        } // blockquote\n\n\n        if (cap = this.rules.blockquote.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'blockquote_start'\n          });\n          cap = cap[0].replace(/^ *> ?/gm, ''); // Pass `top` to keep the current\n          // \"toplevel\" state. This is exactly\n          // how markdown.pl works.\n\n          this.token(cap, top);\n          this.tokens.push({\n            type: 'blockquote_end'\n          });\n          continue;\n        } // list\n\n\n        if (cap = this.rules.list.exec(src)) {\n          src = src.substring(cap[0].length);\n          bull = cap[2];\n          isordered = bull.length > 1;\n          listStart = {\n            type: 'list_start',\n            ordered: isordered,\n            start: isordered ? +bull : '',\n            loose: false\n          };\n          this.tokens.push(listStart); // Get each top-level item.\n\n          cap = cap[0].match(this.rules.item);\n          listItems = [];\n          next = false;\n          l = cap.length;\n          i = 0;\n\n          for (; i < l; i++) {\n            item = cap[i]; // Remove the list item's bullet\n            // so it is seen as the next token.\n\n            space = item.length;\n            item = item.replace(/^ *([*+-]|\\d+\\.) */, ''); // Outdent whatever the\n            // list item contains. Hacky.\n\n            if (~item.indexOf('\\n ')) {\n              space -= item.length;\n              item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n            } // Determine whether the next list item belongs here.\n            // Backpedal if it does not belong in this list.\n\n\n            if (i !== l - 1) {\n              b = block.bullet.exec(cap[i + 1])[0];\n\n              if (bull.length > 1 ? b.length === 1 : b.length > 1 || this.options.smartLists && b !== bull) {\n                src = cap.slice(i + 1).join('\\n') + src;\n                i = l - 1;\n              }\n            } // Determine whether item is loose or not.\n            // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n            // for discount behavior.\n\n\n            loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n            if (i !== l - 1) {\n              next = item.charAt(item.length - 1) === '\\n';\n              if (!loose) loose = next;\n            }\n\n            if (loose) {\n              listStart.loose = true;\n            } // Check for task list items\n\n\n            istask = /^\\[[ xX]\\] /.test(item);\n            ischecked = undefined;\n\n            if (istask) {\n              ischecked = item[1] !== ' ';\n              item = item.replace(/^\\[[ xX]\\] +/, '');\n            }\n\n            t = {\n              type: 'list_item_start',\n              task: istask,\n              checked: ischecked,\n              loose: loose\n            };\n            listItems.push(t);\n            this.tokens.push(t); // Recurse.\n\n            this.token(item, false);\n            this.tokens.push({\n              type: 'list_item_end'\n            });\n          }\n\n          if (listStart.loose) {\n            l = listItems.length;\n            i = 0;\n\n            for (; i < l; i++) {\n              listItems[i].loose = true;\n            }\n          }\n\n          this.tokens.push({\n            type: 'list_end'\n          });\n          continue;\n        } // html\n\n\n        if (cap = this.rules.html.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: this.options.sanitize ? 'paragraph' : 'html',\n            pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]\n          });\n          continue;\n        } // def\n\n\n        if (top && (cap = this.rules.def.exec(src))) {\n          src = src.substring(cap[0].length);\n          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n          tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n\n          if (!this.tokens.links[tag]) {\n            this.tokens.links[tag] = {\n              href: cap[2],\n              title: cap[3]\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (cap = this.rules.table.exec(src)) {\n          item = {\n            type: 'table',\n            header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n            align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n            cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n          };\n\n          if (item.header.length === item.align.length) {\n            src = src.substring(cap[0].length);\n\n            for (i = 0; i < item.align.length; i++) {\n              if (/^ *-+: *$/.test(item.align[i])) {\n                item.align[i] = 'right';\n              } else if (/^ *:-+: *$/.test(item.align[i])) {\n                item.align[i] = 'center';\n              } else if (/^ *:-+ *$/.test(item.align[i])) {\n                item.align[i] = 'left';\n              } else {\n                item.align[i] = null;\n              }\n            }\n\n            for (i = 0; i < item.cells.length; i++) {\n              item.cells[i] = splitCells(item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''), item.header.length);\n            }\n\n            this.tokens.push(item);\n            continue;\n          }\n        } // lheading\n\n\n        if (cap = this.rules.lheading.exec(src)) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'heading',\n            depth: cap[2].charAt(0) === '=' ? 1 : 2,\n            text: cap[1]\n          });\n          continue;\n        } // top-level paragraph\n\n\n        if (top && (cap = this.rules.paragraph.exec(src))) {\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'paragraph',\n            text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n          });\n          continue;\n        } // text\n\n\n        if (cap = this.rules.text.exec(src)) {\n          // Top-level should never reach here.\n          src = src.substring(cap[0].length);\n          this.tokens.push({\n            type: 'text',\n            text: cap[0]\n          });\n          continue;\n        }\n\n        if (src) {\n          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n        }\n      }\n\n      return this.tokens;\n    }\n  }], [{\n    key: \"lex\",\n\n    /**\n     * Static Lex Method\n     */\n    value: function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n  }, {\n    key: \"rules\",\n    get: function get() {\n      return block;\n    }\n  }]);\n\n  return Lexer;\n}();",{"version":3,"sources":["D:\\MyProjects\\HbuilderX-projects\\2.19z\\src\\js\\Lexer.js"],"names":["require","defaults","block","rtrim","splitCells","escape","module","exports","options","tokens","links","Object","create","rules","normal","pedantic","gfm","src","replace","token","top","next","loose","cap","bull","b","item","listStart","listItems","t","space","i","tag","l","isordered","istask","ischecked","newline","exec","substring","length","push","type","code","lastToken","text","trimRight","codeBlockStyle","fences","lang","trim","heading","depth","nptable","header","align","split","cells","test","hr","blockquote","list","ordered","start","match","indexOf","RegExp","bullet","smartLists","slice","join","charAt","undefined","task","checked","html","sanitize","pre","sanitizer","def","toLowerCase","href","title","table","lheading","paragraph","Error","charCodeAt","lexer","Lexer","lex"],"mappings":"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","sourcesContent":["const { defaults } = require('./defaults.js');\nconst { block } = require('./rules.js');\nconst {\n  rtrim,\n  splitCells,\n  escape\n} = require('./helpers.js');\n\n/**\n * Block Lexer\n */\nmodule.exports = class Lexer {\n  constructor(options) {\n    this.tokens = [];\n    this.tokens.links = Object.create(null);\n    this.options = options || defaults;\n    this.rules = block.normal;\n\n    if (this.options.pedantic) {\n      this.rules = block.pedantic;\n    } else if (this.options.gfm) {\n      this.rules = block.gfm;\n    }\n  }\n\n  /**\n   * Expose Block Rules\n   */\n  static get rules() {\n    return block;\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src, options) {\n    const lexer = new Lexer(options);\n    return lexer.lex(src);\n  };\n\n  /**\n   * Preprocessing\n   */\n  lex(src) {\n    src = src\n      .replace(/\\r\\n|\\r/g, '\\n')\n      .replace(/\\t/g, '    ');\n\n    return this.token(src, true);\n  };\n\n  /**\n   * Lexing\n   */\n  token(src, top) {\n    src = src.replace(/^ +$/gm, '');\n    let next,\n      loose,\n      cap,\n      bull,\n      b,\n      item,\n      listStart,\n      listItems,\n      t,\n      space,\n      i,\n      tag,\n      l,\n      isordered,\n      istask,\n      ischecked;\n\n    while (src) {\n      // newline\n      if (cap = this.rules.newline.exec(src)) {\n        src = src.substring(cap[0].length);\n        if (cap[0].length > 1) {\n          this.tokens.push({\n            type: 'space'\n          });\n        }\n      }\n\n      // code\n      if (cap = this.rules.code.exec(src)) {\n        const lastToken = this.tokens[this.tokens.length - 1];\n        src = src.substring(cap[0].length);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken && lastToken.type === 'paragraph') {\n          lastToken.text += '\\n' + cap[0].trimRight();\n        } else {\n          cap = cap[0].replace(/^ {4}/gm, '');\n          this.tokens.push({\n            type: 'code',\n            codeBlockStyle: 'indented',\n            text: !this.options.pedantic\n              ? rtrim(cap, '\\n')\n              : cap\n          });\n        }\n        continue;\n      }\n\n      // fences\n      if (cap = this.rules.fences.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'code',\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: cap[3] || ''\n        });\n        continue;\n      }\n\n      // heading\n      if (cap = this.rules.heading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[1].length,\n          text: cap[2]\n        });\n        continue;\n      }\n\n      // table no leading pipe (gfm)\n      if (cap = this.rules.nptable.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(item.cells[i], item.header.length);\n          }\n\n          this.tokens.push(item);\n\n          continue;\n        }\n      }\n\n      // hr\n      if (cap = this.rules.hr.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'hr'\n        });\n        continue;\n      }\n\n      // blockquote\n      if (cap = this.rules.blockquote.exec(src)) {\n        src = src.substring(cap[0].length);\n\n        this.tokens.push({\n          type: 'blockquote_start'\n        });\n\n        cap = cap[0].replace(/^ *> ?/gm, '');\n\n        // Pass `top` to keep the current\n        // \"toplevel\" state. This is exactly\n        // how markdown.pl works.\n        this.token(cap, top);\n\n        this.tokens.push({\n          type: 'blockquote_end'\n        });\n\n        continue;\n      }\n\n      // list\n      if (cap = this.rules.list.exec(src)) {\n        src = src.substring(cap[0].length);\n        bull = cap[2];\n        isordered = bull.length > 1;\n\n        listStart = {\n          type: 'list_start',\n          ordered: isordered,\n          start: isordered ? +bull : '',\n          loose: false\n        };\n\n        this.tokens.push(listStart);\n\n        // Get each top-level item.\n        cap = cap[0].match(this.rules.item);\n\n        listItems = [];\n        next = false;\n        l = cap.length;\n        i = 0;\n\n        for (; i < l; i++) {\n          item = cap[i];\n\n          // Remove the list item's bullet\n          // so it is seen as the next token.\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+\\.) */, '');\n\n          // Outdent whatever the\n          // list item contains. Hacky.\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic\n              ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n              : item.replace(/^ {1,4}/gm, '');\n          }\n\n          // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n          if (i !== l - 1) {\n            b = block.bullet.exec(cap[i + 1])[0];\n            if (bull.length > 1 ? b.length === 1\n              : (b.length > 1 || (this.options.smartLists && b !== bull))) {\n              src = cap.slice(i + 1).join('\\n') + src;\n              i = l - 1;\n            }\n          }\n\n          // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            listStart.loose = true;\n          }\n\n          // Check for task list items\n          istask = /^\\[[ xX]\\] /.test(item);\n          ischecked = undefined;\n          if (istask) {\n            ischecked = item[1] !== ' ';\n            item = item.replace(/^\\[[ xX]\\] +/, '');\n          }\n\n          t = {\n            type: 'list_item_start',\n            task: istask,\n            checked: ischecked,\n            loose: loose\n          };\n\n          listItems.push(t);\n          this.tokens.push(t);\n\n          // Recurse.\n          this.token(item, false);\n\n          this.tokens.push({\n            type: 'list_item_end'\n          });\n        }\n\n        if (listStart.loose) {\n          l = listItems.length;\n          i = 0;\n          for (; i < l; i++) {\n            listItems[i].loose = true;\n          }\n        }\n\n        this.tokens.push({\n          type: 'list_end'\n        });\n\n        continue;\n      }\n\n      // html\n      if (cap = this.rules.html.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: this.options.sanitize\n            ? 'paragraph'\n            : 'html',\n          pre: !this.options.sanitizer\n            && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]\n        });\n        continue;\n      }\n\n      // def\n      if (top && (cap = this.rules.def.exec(src))) {\n        src = src.substring(cap[0].length);\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        if (!this.tokens.links[tag]) {\n          this.tokens.links[tag] = {\n            href: cap[2],\n            title: cap[3]\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (cap = this.rules.table.exec(src)) {\n        item = {\n          type: 'table',\n          header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          src = src.substring(cap[0].length);\n\n          for (i = 0; i < item.align.length; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          for (i = 0; i < item.cells.length; i++) {\n            item.cells[i] = splitCells(\n              item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n              item.header.length);\n          }\n\n          this.tokens.push(item);\n\n          continue;\n        }\n      }\n\n      // lheading\n      if (cap = this.rules.lheading.exec(src)) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'heading',\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        });\n        continue;\n      }\n\n      // top-level paragraph\n      if (top && (cap = this.rules.paragraph.exec(src))) {\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'paragraph',\n          text: cap[1].charAt(cap[1].length - 1) === '\\n'\n            ? cap[1].slice(0, -1)\n            : cap[1]\n        });\n        continue;\n      }\n\n      // text\n      if (cap = this.rules.text.exec(src)) {\n        // Top-level should never reach here.\n        src = src.substring(cap[0].length);\n        this.tokens.push({\n          type: 'text',\n          text: cap[0]\n        });\n        continue;\n      }\n\n      if (src) {\n        throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n      }\n    }\n\n    return this.tokens;\n  };\n};\n"]}]}